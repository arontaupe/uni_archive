<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Assignment 7</title>
    <style>
        .slider {
            width: 500px;
            height: 10px;
        }

        #canvas {
            float: left;
            margin-right: 1em;
        }
    </style>
</head>
<body>
<canvas id="canvas" width="600" height="600" style="border:1px solid #000000;">
    Your browser does not support the HTML5 canvas tag.
</canvas>
<div>
    <p>Lichtquelle X: <span id="lightXOut"></span></p>
    <label for="lightXIn"></label><input type="range" id="lightXIn" min="-2" max="2" step="0.01" class="slider">
</div>
<div>
    <p>Lichtquelle Y: <span id="lightYOut"></span></p>
    <label for="lightYIn"></label><input type="range" id="lightYIn" min="-2" max="2" step="0.01" class="slider">
</div>
<div>
    <p>Lichtquelle Z: <span id="lightZOut"></span></p>
    <label for="lightZIn"></label><input type="range" id="lightZIn" min="-4" max="0" step="0.01" class="slider">
</div>
<div>
    <p>Ambient: <span id="ambientOut"></span></p>
    <label for="ambientIn"></label><input type="range" id="ambientIn" min="0" max="1" step="0.01" class="slider">
</div>
<div>
    <p>Diffuse: <span id="diffuseOut"></span></p>
    <label for="diffuseIn"></label><input type="range" id="diffuseIn" min="0" max="1" step="0.01" class="slider">
</div>
<div>
    <p>Specular: <span id="specularOut"></span></p>
    <label for="specularIn"></label><input type="range" id="specularIn" min="0" max="1" step="0.01" class="slider">
</div>
<div>
    <p>Shininess: <span id="shininessOut"></span></p>
    <label for="shininessIn"></label><input type="range" id="shininessIn" min="0" max="100" class="slider">
</div>
<script>

    let inputs = [];
    const names = ["lightX", "lightY", "lightZ", "ambient", "diffuse", "specular", "shininess"];
    const initialValues = [2, 2, 0, 0.3, 0.7, 0.1, 10];
    for (let i = 0; i < names.length; i++) {
        inputs[names[i]] = initialValues[i];
        let sliderIn = document.getElementById(names[i] + "In");
        let sliderOut = document.getElementById(names[i] + "Out");
        sliderIn.value = inputs[names[i]].toString();
        sliderOut.innerHTML = inputs[names[i]].toString();
        sliderIn.oninput = function() {
            inputs[names[i]] = parseFloat(this.value);
            sliderOut.innerHTML = inputs[names[i]].toString();
        };
    }

    class Vector {
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        dot(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        }

        cross(v) {
            return new Vector(
                this.y * v.z - this.z * v.y,
                this.z * v.x - this.x * v.z,
                this.x * v.y - this.y * v.x
            );
        }

        norm() {
            return Math.sqrt(this.dot(this));
        }

        normalize() {
            let n = this.norm();
            this.x /= n;
            this.y /= n;
            this.z /= n;
            return this;
        }

        sub(v) {
            return new Vector(
                this.x - v.x,
                this.y - v.y,
                this.z - v.z
            );
        }
    }

    class Point {
        constructor(x = 0, y = 0, z = 0, w = 1) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        dehomogen() {
            this.x /= this.w;
            this.y /= this.w;
            this.z /= this.w;
            this.w = 1;
            return this;
        }

        sub(p) {
            this.dehomogen();
            p.dehomogen();
            return new Vector(
                this.x - p.x,
                this.y - p.y,
                this.z - p.z
            );
        }

        toGL() {
            this.dehomogen();
            return [this.x, this.y, this.z];
        }
    }

    class Matrix {
        constructor(a00 = 1, a01 = 0, a02 = 0, a03 = 0,
                    a10 = 0, a11 = 1, a12 = 0, a13 = 0,
                    a20 = 0, a21 = 0, a22 = 1, a23 = 0,
                    a30 = 0, a31 = 0, a32 = 0, a33 = 1) {
            this.a00 = a00;
            this.a01 = a01;
            this.a02 = a02;
            this.a03 = a03;
            this.a10 = a10;
            this.a11 = a11;
            this.a12 = a12;
            this.a13 = a13;
            this.a20 = a20;
            this.a21 = a21;
            this.a22 = a22;
            this.a23 = a23;
            this.a30 = a30;
            this.a31 = a31;
            this.a32 = a32;
            this.a33 = a33;
        }

        mulMat(m) {
            return new Matrix(
                this.a00 * m.a00 + this.a01 * m.a10 + this.a02 * m.a20 + this.a03 * m.a30,
                this.a00 * m.a01 + this.a01 * m.a11 + this.a02 * m.a21 + this.a03 * m.a31,
                this.a00 * m.a02 + this.a01 * m.a12 + this.a02 * m.a22 + this.a03 * m.a32,
                this.a00 * m.a03 + this.a01 * m.a13 + this.a02 * m.a23 + this.a03 * m.a33,
                this.a10 * m.a00 + this.a11 * m.a10 + this.a12 * m.a20 + this.a13 * m.a30,
                this.a10 * m.a01 + this.a11 * m.a11 + this.a12 * m.a21 + this.a13 * m.a31,
                this.a10 * m.a02 + this.a11 * m.a12 + this.a12 * m.a22 + this.a13 * m.a32,
                this.a10 * m.a03 + this.a11 * m.a13 + this.a12 * m.a23 + this.a13 * m.a33,
                this.a20 * m.a00 + this.a21 * m.a10 + this.a22 * m.a20 + this.a23 * m.a30,
                this.a20 * m.a01 + this.a21 * m.a11 + this.a22 * m.a21 + this.a23 * m.a31,
                this.a20 * m.a02 + this.a21 * m.a12 + this.a22 * m.a22 + this.a23 * m.a32,
                this.a20 * m.a03 + this.a21 * m.a13 + this.a22 * m.a23 + this.a23 * m.a33,
                this.a30 * m.a00 + this.a31 * m.a10 + this.a32 * m.a20 + this.a33 * m.a30,
                this.a30 * m.a01 + this.a31 * m.a11 + this.a32 * m.a21 + this.a33 * m.a31,
                this.a30 * m.a02 + this.a31 * m.a12 + this.a32 * m.a22 + this.a33 * m.a32,
                this.a30 * m.a03 + this.a31 * m.a13 + this.a32 * m.a23 + this.a33 * m.a33
            );
        }

        inverse() {
            // determinants of 2x2 submatrices
            let dt01 = this.a00 * this.a11 - this.a01 * this.a10;
            let dt02 = this.a00 * this.a12 - this.a02 * this.a10;
            let dt03 = this.a00 * this.a13 - this.a03 * this.a10;
            let dt12 = this.a01 * this.a12 - this.a02 * this.a11;
            let dt13 = this.a01 * this.a13 - this.a03 * this.a11;
            let dt23 = this.a02 * this.a13 - this.a03 * this.a12;
            let db01 = this.a20 * this.a31 - this.a21 * this.a30;
            let db02 = this.a20 * this.a32 - this.a22 * this.a30;
            let db03 = this.a20 * this.a33 - this.a23 * this.a30;
            let db12 = this.a21 * this.a32 - this.a22 * this.a31;
            let db13 = this.a21 * this.a33 - this.a23 * this.a31;
            let db23 = this.a22 * this.a33 - this.a23 * this.a32;

            // determinant
            let d = dt01 * db23 - dt02 * db13 + dt03 * db12 + dt12 * db03 - dt13 * db02 + dt23 * db01;
            if (!d) {
                return null;
            }

            // M^(-1) = 1 / det(M) * adj(M)
            d = 1.0 / d;
            return new Matrix(
                d * (this.a11 * db23 - this.a12 * db13 + this.a13 * db12),
                d * (this.a02 * db13 - this.a01 * db23 - this.a03 * db12),
                d * (this.a31 * dt23 - this.a32 * dt13 + this.a33 * dt12),
                d * (this.a22 * dt13 - this.a21 * dt23 - this.a23 * dt12),
                d * (this.a12 * db03 - this.a10 * db23 - this.a13 * db02),
                d * (this.a00 * db23 - this.a02 * db03 + this.a03 * db02),
                d * (this.a32 * dt03 - this.a30 * dt23 - this.a33 * dt02),
                d * (this.a20 * dt23 - this.a22 * dt03 + this.a23 * dt02),
                d * (this.a10 * db13 - this.a11 * db03 + this.a13 * db01),
                d * (this.a01 * db03 - this.a00 * db13 - this.a03 * db01),
                d * (this.a30 * dt13 - this.a31 * dt03 + this.a33 * dt01),
                d * (this.a21 * dt03 - this.a20 * dt13 - this.a23 * dt01),
                d * (this.a11 * db02 - this.a10 * db12 - this.a12 * db01),
                d * (this.a00 * db12 - this.a01 * db02 + this.a02 * db01),
                d * (this.a31 * dt02 - this.a30 * dt12 - this.a32 * dt01),
                d * (this.a20 * dt12 - this.a21 * dt02 + this.a22 * dt01),
            );
        }

        transpose() {
            return new Matrix(
                this.a00, this.a10, this.a20, this.a30,
                this.a01, this.a11, this.a21, this.a31,
                this.a02, this.a12, this.a22, this.a32,
                this.a03, this.a13, this.a23, this.a33
            );
        }

        toGL() {
            return [
                this.a00, this.a10, this.a20, this.a30,
                this.a01, this.a11, this.a21, this.a31,
                this.a02, this.a12, this.a22, this.a32,
                this.a03, this.a13, this.a23, this.a33
            ];
        }
    }

    // language=GLSL
    const vsSource = `
        precision mediump float;

        attribute vec4 aPosition;
        attribute vec4 aNormal;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uNormalMatrix;
        uniform mat4 uProjectionMatrix;
        uniform vec3 uLightPos;
        uniform vec3 uLightColor;
        uniform float uAmbient;
        uniform float uDiffuse;
        uniform float uSpecular;
        uniform float uShininess;

        varying vec3 vPosition;
        varying vec3 vNormal;

        void main(void) {
            vec4 modelViewPosition = uModelViewMatrix * aPosition;
            vPosition = modelViewPosition.xyz;
            vNormal = normalize((uNormalMatrix * aNormal).xyz);

            // TODO: Aufgabe a

            gl_Position = uProjectionMatrix * modelViewPosition;
        }
    `;

    // language=GLSL
    const fsSource = `
        precision mediump float;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uNormalMatrix;
        uniform mat4 uProjectionMatrix;
        uniform vec3 uLightPos;
        uniform vec3 uLightColor;
        uniform float uAmbient;
        uniform float uDiffuse;
        uniform float uSpecular;
        uniform float uShininess;

        varying vec3 vPosition;
        varying vec3 vNormal;

        void main(void) {

            // TODO: Aufgaben b und c

            vec3 n = vNormal;
            vec3 v = normalize(-vPosition);
            vec3 l = normalize(uLightPos - vPosition);
            vec3 r = 2.0 * n * dot(n, l) - l;
            vec3 Ca = uAmbient * vec3(1, 0, 1);
            vec3 Cd = uDiffuse * vec3(1, 0, 1);
            vec3 Cs = uSpecular * vec3(1, 1, 1);
            float s = uShininess;
            vec3 color = (Ca + Cd * max(0.0, dot(l, n)) + Cs * pow(max(0.0, dot(v, r)), s)) * uLightColor;
            gl_FragColor = vec4(color, 1);
        }
    `;

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    if (!gl) {
        console.log('Unable to initialize WebGL. Your browser or machine may not support it.');
    }

    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.log('An error occurred compiling the shaders:\n' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.log('Unable to initialize the shader program:\n' + gl.getProgramInfoLog(shaderProgram));
    }

    const programInfo = {
        program: shaderProgram,
        attribLocations: {
            position: gl.getAttribLocation(shaderProgram, 'aPosition'),
            normal: gl.getAttribLocation(shaderProgram, 'aNormal'),
            tangent: gl.getAttribLocation(shaderProgram, 'aTangent'),
            textureCoordinate: gl.getAttribLocation(shaderProgram, 'aTextureCoordinate')
        },
        uniformLocations: {
            modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
            normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
            projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
            lightPos: gl.getUniformLocation(shaderProgram, 'uLightPos'),
            lightColor: gl.getUniformLocation(shaderProgram, 'uLightColor'),
            ambient: gl.getUniformLocation(shaderProgram, 'uAmbient'),
            diffuse: gl.getUniformLocation(shaderProgram, 'uDiffuse'),
            specular: gl.getUniformLocation(shaderProgram, 'uSpecular'),
            shininess: gl.getUniformLocation(shaderProgram, 'uShininess'),
            texture: gl.getUniformLocation(shaderProgram, 'uTexture'),
            normalMap: gl.getUniformLocation(shaderProgram, 'uNormalMap')
        }
    };

    const positions = [
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        -1, 1, 1,
        1, -1, 1,
        1, -1, -1,
        1, 1, -1,
        1, 1, 1,
        1, -1, -1,
        -1, -1, -1,
        -1, 1, -1,
        1, 1, -1,
        -1, -1, -1,
        -1, -1, 1,
        -1, 1, 1,
        -1, 1, -1,
        -1, -1, -1,
        1, -1, -1,
        1, -1, 1,
        -1, -1, 1,
        -1, 1, 1,
        1, 1, 1,
        1, 1, -1,
        -1, 1, -1
    ];
    const normals = [
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        1, 0, 0,
        1, 0, 0,
        1, 0, 0,
        1, 0, 0,
        0, 0, -1,
        0, 0, -1,
        0, 0, -1,
        0, 0, -1,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0
    ];
    const textureCoordinates = [
        0.25, 0.5,
        0.5, 0.5,
        0.5, 0.75,
        0.25, 0.75,
        0.5, 0.5,
        0.75, 0.5,
        0.75, 0.75,
        0.5, 0.75,
        0.75, 0.5,
        1, 0.5,
        1, 0.75,
        0.75, 0.75,
        0, 0.5,
        0.25, 0.5,
        0.25, 0.75,
        0, 0.75,
        0.25, 0.25,
        0.5, 0.25,
        0.5, 0.5,
        0.25, 0.5,
        0.25, 0.75,
        0.5, 0.75,
        0.5, 1,
        0.25, 1
    ];
    const indices = [
        0, 1, 2,
        2, 3, 0,
        4, 5, 6,
        6, 7, 4,
        8, 9, 10,
        10, 11, 8,
        12, 13, 14,
        14, 15, 12,
        16, 17, 18,
        18, 19, 16,
        20, 21, 22,
        22, 23, 20
    ];

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    const normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    const textureCoordinateBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinateBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    let mouseRotMat = new Matrix();
    const lookAtMat = new Matrix(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, -3,
        0, 0, 0, 1
    );
    const projectionMat = new Matrix(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, -1.5, -2.5,
        0, 0, -1, 0
    );

    function createTexture(data) {
        let texture = gl.createTexture();
        texture.image = new Image();
        texture.image.onload = function() {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        texture.image.src = data;
        return texture;
    }

    let texture = createTexture("data:image/png;base64,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BAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAAAggAAAAAEEAAAAAAgAACAAAAAAQQAAAAACCAAAAAAAABBAAAAAAIIAAAAABAAAEAAAAA/sp77rn/B35ujwHvL4cEAAAAAElFTkSuQmCC");

    function update() {
        const modelViewMat = lookAtMat.mulMat(mouseRotMat);
        const normalMat = modelViewMat.inverse().transpose();
        const lightPos = new Point(inputs["lightX"], inputs["lightY"], inputs["lightZ"]);

        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.clearDepth(1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(programInfo.program);

        {
            const numComponents = 3;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(
                programInfo.attribLocations.position,
                numComponents,
                type,
                normalize,
                stride,
                offset);
            gl.enableVertexAttribArray(programInfo.attribLocations.position);
        }
        {
            const numComponents = 3;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.vertexAttribPointer(
                programInfo.attribLocations.normal,
                numComponents,
                type,
                normalize,
                stride,
                offset);
            gl.enableVertexAttribArray(programInfo.attribLocations.normal);
        }
        {
            const numComponents = 2;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinateBuffer);
            gl.vertexAttribPointer(
                programInfo.attribLocations.textureCoordinate,
                numComponents,
                type,
                normalize,
                stride,
                offset);
            gl.enableVertexAttribArray(programInfo.attribLocations.textureCoordinate);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        gl.uniformMatrix4fv(
            programInfo.uniformLocations.modelViewMatrix,
            false,
            modelViewMat.toGL());
        gl.uniformMatrix4fv(
            programInfo.uniformLocations.normalMatrix,
            false,
            normalMat.toGL());
        gl.uniformMatrix4fv(
            programInfo.uniformLocations.projectionMatrix,
            false,
            projectionMat.toGL());
        gl.uniform3fv(programInfo.uniformLocations.lightPos, lightPos.toGL());
        gl.uniform3fv(programInfo.uniformLocations.lightColor, [1, 1, 1]);
        gl.uniform1f(programInfo.uniformLocations.ambient, inputs["ambient"]);
        gl.uniform1f(programInfo.uniformLocations.diffuse, inputs["diffuse"]);
        gl.uniform1f(programInfo.uniformLocations.specular, inputs["specular"]);
        gl.uniform1f(programInfo.uniformLocations.shininess, inputs["shininess"]);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(programInfo.uniformLocations.texture, 0);

        {
            const type = gl.UNSIGNED_SHORT;
            const offset = 0;
            gl.drawElements(gl.TRIANGLES, indices.length, type, offset);
        }

        requestAnimationFrame(update);
    }

    requestAnimationFrame(update);

    let down = false;
    let x0;
    let y0;

    document.getElementById("canvas").addEventListener("mousedown", function(event) {
        down = true;
        x0 = event.clientX - 300;
        y0 = 300 - event.clientY;
    });

    document.getElementById("canvas").addEventListener("mousemove", function(event) {
        if (down) {
            let x1 = event.clientX - 300;
            let y1 = 300 - event.clientY;
            if (x0 !== x1 || y0 !== y1) {
                let v0 = new Vector(x0, y0, 300);
                v0.normalize();
                let v1 = new Vector(x1, y1, 300);
                v1.normalize();
                if (v0.sub(v1).norm() > 0.001) {
                    let n = v0.cross(v1);
                    let alpha = Math.asin(n.norm());
                    n.normalize();
                    let sin = Math.sin(alpha);
                    let cos = Math.cos(alpha);
                    mouseRotMat = new Matrix(
                        (1 - cos) * n.x * n.x + cos, (1 - cos) * n.x * n.y - sin * n.z, (1 - cos) * n.x * n.z + sin * n.y, 0,
                        (1 - cos) * n.y * n.x + sin * n.z, (1 - cos) * n.y * n.y + cos, (1 - cos) * n.y * n.z - sin * n.x, 0,
                        (1 - cos) * n.z * n.x - sin * n.y, (1 - cos) * n.z * n.y + sin * n.x, (1 - cos) * n.z * n.z + cos, 0,
                        0, 0, 0, 1
                    ).mulMat(mouseRotMat);
                }
                x0 = x1;
                y0 = y1;
            }
        }
    });

    document.getElementById("canvas").addEventListener("mouseup", function() {
        down = false;
    });

</script>
</body>
</html>
